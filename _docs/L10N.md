### Documentation for the "L10N" class (a.k.a., the "L10N handler").

*Used by CIDRAM and phpMussel to handle L10N data, the L10N handler reads in an array of L10N strings and provides some safe and simple methods for manipulating and returning those strings when needed, and for handling __cardinal__ plurals, where integers and fractions are concerned alike, based upon the pluralisation rules specified by the L10N from a range of various pluralisation rules available, to be able to suit the needs of most known languages.*

---


### How to use:

- [Working with singular forms.](#working-with-singular-forms)
- [Working with plural forms.](#working-with-plural-forms)
- [What rules to use for what language?](#what-rules-to-use-for-what-language)
- [Assigning rules automatically.](#assigning-rules-automatically)
- [Leveraging the L10N handler and the YAML class in conjunction.](#leveraging-the-l10n-class-and-the-yaml-class-in-conjunction)
- [Object chaining.](#object-chaining)

---


#### Working with singular forms.

Let's begin with an example.

```PHP
<?php
// An example L10N array that uses English.
$DataEN = [
    'IntegerRule' => 'int2Type4',
    'FractionRule' => 'int1',
    'MyName' => 'Hello! My name is %s.',
    'YourName' => 'What is your name?',
    'DoYouSpeak' => 'Do you speak English?'
];

// An example L10N array that uses French.
$DataFR = [
    'IntegerRule' => 'int2Type3',
    'FractionRule' => 'fraction2Type1',
    'MyName' => 'Bonjour¬†! Je m\'appelle %s.',
    'YourName' => 'Quel est votre nom¬†?'
];

// Construction a new L10N instance using French as the main L10N array and
// English as the fallback L10N array.
$L10N = new \Maikuolan\Common\L10N($DataFR, $DataEN);

// Attempt to fetch and sprint our desired L10N strings.
echo sprintf($L10N->getString('MyName'), 'Mary Sue') . PHP_EOL;
echo $L10N->getString('YourName') . PHP_EOL;
echo $L10N->getString('DoYouSpeak') . PHP_EOL;
```

The example above, produces this output:

```
Bonjour ! Je m'appelle Mary Sue.
Quel est votre nom ?
Do you speak English?
```

##### *What's happening here?*

The `getString` method provides a safe way fetch an L10N string. If the string exists in the main L10N array, it will be returned from the main L10N array. If the string doesn't exist in the L10N array, but exists in the fallback L10N array, it will be returned from the fallback L10N array. If the string doesn't exist in either of the two arrays, an empty string will be returned.

```PHP
public function getString(string $String): string;
```

The reason that the class utilises both a main array and a fallback array, is that it enables the class to support L10N data in situations where the implementation may utilise translations of L10N data into several different languages, and where some of those translations aren't complete, in a safe way.

Imagine the following situation, which doesn't use this class:

```PHP
<?php
// Currently using:
$Language = 'FR';

if ($Language === 'FR') {
    // An example L10N array that uses French.
    $Lang = [
        'YourName' => 'Quel est votre nom¬†?'
    ];
}

elseif ($Language === 'EN') {
    // An example L10N array that uses English.
    $Lang = [
        'YourName' => 'What is your name?',
        'DoYouSpeak' => 'Do you speak English?'
    ];
}

echo $Lang['DoYouSpeak'] . PHP_EOL;
```

It would produce an error:

```
<br />
<b>Notice</b>:  Undefined index: DoYouSpeak in <b>\foo\bar.php</b> on line <b>20</b><br />
```

Of course, that situation actually demonstrates a very poor way to implement L10N support anyway. But, the error is produced, because the `DoYouSpeak` string hadn't been translated into French yet. If it had used English, it would've produced the desired string. Arguably, too, errors could be avoided simply by ensuring that translations exist for every possible string, in every possible translation, prior to deployment. But I think, the way that this class provides the ability to rely on a default language as a fallback in such cases, and that it simply returns an empty string when the string doesn't exist at all, is perhaps a much easier, much simpler way to avoid these kinds of errors.

---


#### Working with plural forms.

Let's begin with an example.

```PHP
<?php
// An example L10N array that uses English.
$DataEN = [
    'IntegerRule' => 'int2Type4',
    'FractionRule' => 'int1',
    'apples' => [
        'There is %s apple on the tree.',
        'There are %s apples on the tree.'
    ],
    'oranges' => [
        'There is %s orange on the tree.',
        'There are %s oranges on the tree.'
    ],
];

// An example L10N array that uses Russian.
$DataRU = [
    'IntegerRule' => 'int3Type4',
    'FractionRule' => 'int1',
    'apples' => [
        '–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å %s —è–±–ª–æ–∫–æ.',
        '–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å %s —è–±–ª–æ–∫–∞.',
        '–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å %s —è–±–ª–æ–∫.'
    ]
];

// Construction a new L10N instance using Russian as the main L10N array and
// English as the fallback L10N array.
$L10N = new \Maikuolan\Common\L10N($DataRU, $DataEN);

// How many apples are there on the tree?
foreach ([0, 1, 2, 3, 4, 5] as $Number) {
    echo sprintf($L10N->getPlural($Number, 'apples'), $Number) . PHP_EOL;
}
echo PHP_EOL;

// How many oranges are there on the tree?
foreach ([0, 1, 2, 3, 4, 5] as $Number) {
    echo sprintf($L10N->getPlural($Number, 'oranges'), $Number) . PHP_EOL;
}
echo PHP_EOL;
```

The example above, produces this output:

```
–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å 0 —è–±–ª–æ–∫.
–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å 1 —è–±–ª–æ–∫–æ.
–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å 2 —è–±–ª–æ–∫–∞.
–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å 3 —è–±–ª–æ–∫–∞.
–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å 4 —è–±–ª–æ–∫–∞.
–ù–∞ –¥–µ—Ä–µ–≤–µ –µ—Å—Ç—å 5 —è–±–ª–æ–∫.

There are 0 oranges on the tree.
There is 1 orange on the tree.
There are 2 oranges on the tree.
There are 3 oranges on the tree.
There are 4 oranges on the tree.
There are 5 oranges on the tree.
```

##### *What's happening here?*

The `getPlural` method can be used when there are multiple plural forms available for a particular L10N string. In our example, "apples" and "oranges" have multiple plural forms (counting how many items are on a hypothetical tree). The example uses the Russian data as the main L10N array, and English as the fallback L10N array. The fallback L10N array is used when the desired L10N data doesn't exist in the main L10N array, which is why the above example produces Russian apples and English oranges.

```PHP
public function getPlural($Number, string $String): string;
```

The L10N handler knows which available plural form to select for a given number because of the plural rules specified by the L10N array (`IntegerRule` and `FractionRule`). When there's a chance that you might be working with plurals, these two elements should exist in the arrays, to ensure that the correct plural forms are returned.

The order that plural forms should appear in an L10N array always begins at the plural form that corresponds to one item (the singular), followed by plural forms as they appear sequentially (corresponding to two items, three items, four items, etc). If there is a specific plural form for zero, that plural form should appear last.

##### *That's integers. What about fractions?*

The demonstration above shows how we can use the class to fetch an appropriate plural form for cardinal integers. The class also supports fractions, too (for those languages that have distinct plural forms for different ranges of fractions):

```PHP
<?php
$DataFR = [
    'IntegerRule' => 'int2Type3',
    'FractionRule' => 'fraction2Type1',
    'Seconds' => [
        'La page charg√©e en %s seconde.',
        'La page charg√©e en %s secondes.'
    ]
];

$L10N = new \Maikuolan\Common\L10N($DataFR);

// Example page load times.
foreach ([0.1, 0.5, 1.1, 1.5, 2.1, 2.5, 3.1, 3.5, 4.1, 4.5, 5.1] as $Number) {
    echo sprintf($L10N->getPlural($Number, 'Seconds'), $Number) . PHP_EOL;
}
echo PHP_EOL;
```

Produces:

```
La page charg√©e en 0.1 seconde.
La page charg√©e en 0.5 seconde.
La page charg√©e en 1.1 seconde.
La page charg√©e en 1.5 seconde.
La page charg√©e en 2.1 secondes.
La page charg√©e en 2.5 secondes.
La page charg√©e en 3.1 secondes.
La page charg√©e en 3.5 secondes.
La page charg√©e en 4.1 secondes.
La page charg√©e en 4.5 secondes.
La page charg√©e en 5.1 secondes.
```

Additionally, as you might've noticed in the above example, the fallback L10N array is optional. If you want to work with only one language, or if multiple language versions don't exist, it's okay to use only one L10N array (the main L10N array).

---


#### What rules to use for what language?

*The information listed in the table below is generally based upon [Unicode's CLDR page on Language Plural Rules](https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/language_plural_rules.html) (which also serves as the general basis for the rules for [grammatical number](https://en.wikipedia.org/wiki/Grammatical_number) supported by the class). Information based upon other sources will be marked accordingly. If any of the listed information is wrong, erroneous, or incomplete, any corrections, additions, etc that you can think of would be invited and welcome (please create a pull request, or create an [issue](https://github.com/Maikuolan/Common/issues) if creating a pull request isn't possible). Please also be aware that I am NOT a professional linguist! If you ask me for the correct rules to use for a particular language, I'll only be able to answer if I'm able to find a reliable source somewhere online to help determine that information.*

*‚Ä†1: Language isn't listed on Unicode's CLDR page, but the required information for it can be found elsewhere (if a single, particular information source is the sole or primarily used information source, it will be linked next to the language, where this mark occurs).*

Language | `IntegerRule` | `FractionRule` | Notes
:--|:--|:--|:--
`********************************` | `********` | `********` | `********`
Afrikaans<br />Albanian (Shqipe)<br />Aragonese<br />Asturian (Asturianu)<br />Asu<br />Azerbaijani (Az…ôrbaycan)<br />Balochi (ÿ®ŸÑ€è⁄Ü€å)<br />Basque (Euskara)<br />Bemba<br />Bena<br />Bodo (‡§¨‡§°‡§º‡•ã)<br />Bulgarian (–ë—ä–ª–≥–∞—Ä—Å–∫–∏)<br />Catalan (Catal√†)<br />Chechen<br />Cherokee (·è£·é≥·é©)<br />Chiga<br />Divehi<br />Dutch (Nederlandse)<br />English<br />Esperanto<br />Estonian (Eesti keel)<br />European Portuguese (Portugu√™s)<br />Ewe (E ãegbe)<br />Faroese (F√∏royskt)<br />Finnish (Suomi)<br />Friulian<br />Galician (Galego)<br />Ganda (L√πG√°√†nda)<br />Georgian (·É•·Éê·É†·Éó·É£·Éö·Éò)<br />German (Deutsch)<br />Greek (ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨)<br />Greenlandic (Kalaallisut)<br />Hausa (ÿ≠ŸéŸàŸíÿ≥Ÿé)<br />Hawaiian ( ª≈çlelo Hawai ªi)<br />Hungarian (Magyar)<br />Ido<br />Interlingua<br />Italian (Italiano)<br />Jju<br />Kako<br />Kashmiri (‡§ï‡•â‡§∂‡•Å‡§∞, ŸÉŸ≤ÿ¥Ÿèÿ±)<br />Kazakh (“ö–∞–∑–∞“õ —Ç—ñ–ª—ñ)<br />Kurdish (Kurd√Æ)<br />Kyrgyz (–ö—ã—Ä–≥—ã–∑ —Ç–∏–ª–∏)<br />Ligurian<br />Luxembourgish (L√´tzebuergesch)<br />Machame<br />Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)<br />Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)<br />Masai<br />Maori (MƒÅori) *[‚Ä†1](https://en.wikipedia.org/wiki/M%C4%81ori_language)*<br />Meta º<br />Mongolian (–ú–æ–Ω–≥–æ–ª)<br />Nahuatl (NƒÅhuatl)<br />Ndebele<br />Nepali (‡§®‡•á‡§™‡§æ‡§≤‡•Ä)<br />Ngiemboon<br />Ngomba<br />Norwegian (Norsk)<br />Norwegian Bokm√•l<br />Norwegian Nynorsk<br />Nyanja<br />Nyankole<br />Odia (‡¨ì‡¨°‡¨º‡¨ø‡¨Ü)<br />Oromo (·ä¶·àÆ·àû·çû)<br />Ossetic<br />Papiamento (Papiamentu)<br />Pashto (Ÿæ⁄öÿ™Ÿà)<br />Romansh (Rumantsch)<br />Rombo<br />Rwa<br />Saho<br />Samburu<br />Samoan<br />Sardinian (Limba Sarda)<br />Scots *[‚Ä†1](http://www.scots-online.org/grammar/numbers.asp)*<br />Sena<br />Shambala<br />Shona<br />Sicilian (Sicilianu)<br />Sindarin *[‚Ä†1](https://en.wikipedia.org/wiki/Sindarin)*<br />Sindhi (ÿ≥ŸÜ⁄åŸä)<br />Soga<br />Somali (Soomaaliga)<br />Southern Sotho (Sesotho)<br />Spanish (Espa√±ol)<br />Swahili (Kiswahili)<br />Swati<br />Swedish (Svenska)<br />Swiss German<br />Syriac (‹†‹´‹¢‹ê ‹£‹ò‹™‹ù‹ù‹ê)<br />Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)<br />Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)<br />Teso<br />Tigre (·âµ·åç·à®, ·âµ·åç·à¨)<br />Tsonga (xiTsonga)<br />Tswana (Setswana)<br />Turkish (T√ºrk√ße)<br />Turkmen (–¢“Ø—Ä–∫m–µ–Ω—á–µ)<br />Tyap<br />Urdu (‚Äèÿßÿ±ÿØŸà‚Äè)<br />Uyghur (ÿ¶€áŸäÿ∫€áÿ±⁄Ü€ï, –£–π“ì—É—Ä—á”ô)<br />Uzbek (O'zbek)<br />Venda (tshiVen·∏ìa)<br />Volap√ºk<br />Vunjo<br />Walser<br />Western Frisian (Frysk)<br />Xhosa (isiXhosa)<br />Yiddish (◊ô◊ô÷¥◊ì◊ô◊©) | `int2Type4` | `int1`
Akan<br />Bihari<br />Gun<br />Klingon (tlhIngan Hol, Ô£§Ô£óÔ£úÔ£êÔ£õ Ô£ñÔ£ùÔ£ô) *[‚Ä†1](https://en.wikibooks.org/wiki/Klingon/Grammar/Plurals)*<br />Lingala (Ling√°la)<br />Malagasy<br />Northern Sotho (Sesotho)<br />Punjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä) *‚Ä°1*<br />Sinhala (‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω)<br />Tigrinya (·âµ·åç·à≠·äõ)<br />Walloon (Walon) | `int2Type3` | `int1` | *‚Ä°1: Classification includes (groups together with): Changvi, Chenavari, Dhani, Doabi, Hindko, Jafri, Jangli, Jhangochi, Khetrani, Lahnda, Majhi, Malwai, Pahari-Potowari, Panjistani, Pothohari, Puadhi, Rachnavi, Saraiki, Shahpuri.*
Amharic (·ä†·àõ·à≠·äõ)<br />Assamese (‡¶Ö‡¶∏‡¶Æ‡ßÄ‡¶Ø‡¶º‡¶æ)<br />Bangla/Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)<br />Dogri (ë†ñë†µë†åë†§ë†Æ)<br />Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä)<br />Hindi (‡§π‡§ø‡§Ç‡§¶‡•Ä)<br />Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)<br />Nigerian Pidgin<br />Persian/Farsi (ŸÅÿßÿ±ÿ≥€å)<br />Zulu (isiZulu) | `int2Type3` | `fraction2Type2`
Arabic (<code dir="rtl">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</code>) *‚Ä°1* | `int6Type1` | `int1` | *‚Ä°1: My source information suggests 6 distinct grammatical numbers used, but I haven't been able to successfully replicate this via online translators or dictionaries in most cases, so I'm not entirely sure about it.*
Armenian (’∞’°’µ’•÷Ä’•’∂)<br />Bhojpuri (‡§≠‡•ã‡§ú‡§™‡•Å‡§∞‡•Ä)<br />Brazilian Portuguese (Portugues do Brasil)<br />French (Fran√ßais)<br />Fulah<br />Kabyle (ÿ´ÿßŸÇÿ®ÿßŸäŸÑŸäÿ´) | `int2Type3` | `fraction2Type1`
Bambara<br />Bhutanese/Dzongkha (‡Ω¢‡æ´‡Ωº‡ΩÑ‡ºã‡ΩÅ)<br />Burmese (·Äª·Äô·Äî·Äπ‚Äã·Äô·Ä¨·Äò·Ä¨·Äû·Ä¨)<br />Chinese (‰∏≠Êñá) *‚Ä°1*<br />Hmong Njua<br />Igbo<br />Indonesian (Bahasa Indonesia)<br />Japanese (Êó•Êú¨Ë™û)<br />Javanese (Jawa)<br />Kabuverdianu<br />Khmer (·ûó·û∂·ûü·û∂·ûÅ·üí·ûò·üÇ·ûö)<br />Korean (ÌïúÍµ≠Ïñ¥)<br />Koyraboro Senni<br />Lakota (Lak»ü√≥tiyapi)<br />Lao (‡∫û‡∫≤‡∫™‡∫≤‡∫•‡∫≤‡∫ß)<br />Lojban<br />Makonde<br />Malay (Bahasa Melayu)<br />N‚ÄôKo (ﬂíﬂûﬂè)<br />Osage<br />Sakha<br />Sango<br />Sichuan Yi (ÍÜàÍå†Íâô)<br />Thai (‡πÑ‡∏ó‡∏¢)<br />Tibetan (‡Ωñ‡Ωº‡Ωë‡ºã‡Ω¶‡æê‡Ωë)<br />Toki Pona *[‚Ä†1](http://tokipona.net/tp/janpije/originallessons-tp3.php)*<br />Tongan (Faka-Tonga)<br />Vietnamese (Ti·∫øng Vi·ªát)<br />Wolof (Wollof)<br />Yoruba (Yor√πb√°) | `int1` | `int1` | Although `int1`+`int1` could *imply* that there aren't plural forms for a particular language, it should be noted that in most cases, plurality can be inferred by context, indicated by [specificity](https://en.wikipedia.org/wiki/Specificity_(linguistics)), [reduplication](https://en.wikipedia.org/wiki/Reduplication), or otherwise determined by some other means. It doesn't mean that there aren't plurals. Rather, it simply means that for those languages, it doesn't mean anything for this particular class.<br /><br />*‚Ä°1: Whether simplified (ÂÇ≥Áµ±) or traditional (ÁÆÄ‰Ωì), Cantonese (Âπø‰∏úËØù) or Mandarin (ÊôÆÈÄöËØù), or whatever else, pluralisation rules are the same (AFAICT).*
Belarusian (–ë–µ–ª–∞—Ä—É—Å–∫–∞—è –º–æ–≤–∞)<br />Bosnian (Bosanski)<br />Croatian (Hrvatski)<br />Russian (–†—É—Å—Å–∫–∏–π)<br />Serbian (–°—Ä–ø—Å–∫–∏)<br />Serbo-Croatian<br />Ukrainian (–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞) | `int3Type4` | `int1`
Breton (Brezhoneg) | `int4Type3` | `int1`
Colognian | `int3Type2` | `int1`
Fijian<br />Inari Sami (Anar√¢≈°kiel√¢)<br />Inuktitut<br />Lule Sami (Julevs√°megiella)<br />Nama (Khoekhoegowab)<br />Northern Sami (S√°megiellaa)<br />Santali (·±•·±ü·±±·±õ·±ü·±≤·±§)<br />Skolt Sami (Nu√µrtts√§√§‚Äôm)<br />Southern Sami (√Öarjelsaemien g√Øele) | `int3Type3` | `int1`
Czech (ƒåe≈°tina)<br />Slovak (Slovenƒçina) | `int3Type9` | `int1`
Danish (Dansk) | `int2Type4` | `fraction2Type1`
Cebuano<br />Filipino<br />Tagalog | `int2Type1` | `int1`
Hebrew (◊¢◊ë◊®◊ô◊™) | `int4Type5` | `int1`
Icelandic (√çslenska)<br />Macedonian (–ú–∞–∫–µ–¥–æ–Ω—Å–∫–∏) | `int2Type2` | `int1`
Irish (Gaeilge) | `int5Type1` | `int1`
Langi | `int3Type2` | `fraction2Type1`
Latvian (Latvie≈°u)<br />Prussian | `int3Type1` | `int1`
Lithuanian (Lietuvi≈≥) | `int3Type6` | `int1`
Lower Sorbian (Dolnoserbski)<br />Slovenian (Sloven≈°ƒçina)<br />Upper Sorbian (Hornjoserbsce) | `int4Type4` | `int1`
Maltese (Malti) | `int4Type6` | `int1`
Manx (Vanninagh) | `int4Type1` | `int1`
Moldavian (MoldoveneascƒÉ)<br />Romanian (Rom√¢nƒÉ) | `int3Type8` | `int1`
Na'vi *[‚Ä†1](https://en.wikibooks.org/wiki/Na%27vi/Nouns)* | `int4Type7` | `int1`
Polish (Polski) | `int3Type5` | `int1`
Quenya *[‚Ä†1](http://tolkiengateway.net/wiki/Quenya_Grammar#Expressing_Numbers) ‚Ä°1*<br />Tokelauan *[‚Ä†1](http://www.thebookshelf.auckland.ac.nz/docs/TokelauDictionary/tokelau002.pdf)* | `int3Type10` | `int1` | *‚Ä°1: Quenya actually has four distinct plural forms, but the L10N handler rules to use for Quenya suggests three, because in this context, we're only concerned with grammatical number. Whether a plural form is partitive or non-partitive is outside the scope of these rules, but can be determined by context, and doesn't conflict with the grammatical number.*
Scottish Gaelic (G√†idhlig) | `int4Type2` | `int1`
Tachelhit | `int3Type7` | `fraction2Type2`
Welsh (Cymraeg) | `int6Type2` | `int1`
Cornish (Kernewek) | `int6Type3` | `int1`

---


#### Assigning rules automatically.

If you want, you can have the L10N handler assign the appropriate rules automatically, saving yourself the trouble of figuring out which rules you should be using for your L10N data. All you need to know is the correct language codes for the languages you're working with.

To have the L10N handler assign the appropriate rules automatically, you can use the `autoAssignRules` method.

```PHP
public function autoAssignRules($Code, $FallbackCode = '');
```

The `autoAssignRules` method accepts two parameters: The first parameter is the language code of the language for your primary L10N data. The second parameter is optional, and is the language code of the language for your fallback L10N data.

Example:

```PHP
<?php
// An example L10N array that uses English.
$DataEN = [
    'YourName' => 'What is your name?',
    'DoYouSpeak' => 'Do you speak English?'
];

// An example L10N array that uses French.
$DataFR = [
    'YourName' => 'Quel est votre nom¬†?'
    'DoYouSpeak' => 'Parlez-vous Fran√ßais¬†?'
];

// Construction a new L10N instance using French as the main L10N array and
// English as the fallback L10N array.
$L10N = new \Maikuolan\Common\L10N($DataFR, $DataEN);

// Let's pretend we don't know which rules to use, but we know the language
// codes for the languages we're using ("en" for English and "fr" for French;
// or if we wanted, we could go more specific, too; like "en-US" for US English
// and "fr-CA" for Canadian French, or "fr-FR" for French spoken in France,
// etc). We'll use the "autoAssignRules" method to assign the rules for us
// automatically.
$L10N->autoAssignRules('fr-FR', 'en-US');
```

---


#### Leveraging the L10N handler and the YAML class in conjunction.

Leveraging the L10N handler and the YAML class in conjunction can provide an extremely convenient way to manage your implementation's L10N needs. CIDRAM and phpMussel both do this. For CIDRAM and phpMussel, each language's L10N data is stored in distinct, separate YAML files.

As a hypothetical example:

`english.yaml`:
```YAML
## English YAML file.

IntegerRule: "int2Type4"
FractionRule: "int1"

Hello: "Hello!"
Today's cakes:
 - "Today, there is %s cake in the shop."
 - "Today, there are %s cakes in the shop."
Yesterday's cakes:
 - "But, I already ate %s cake yesterday."
 - "But, I already ate %s cakes yesterday."
```

`russian.yaml`:
```YAML
## Russian YAML file.

IntegerRule: "int3Type4"
FractionRule: "int1"

Hello: "–ü—Ä–∏–≤–µ—Ç!"
Today's cakes:
 - "–°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å %s —Ç–æ—Ä—Ç."
 - "–°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å %s —Ç–æ—Ä—Ç–∞."
 - "–°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å %s —Ç–æ—Ä—Ç–æ–≤."
Yesterday's cakes:
 - "–ù–æ —è —É–∂–µ —Å—ä–µ–ª %s —Ç–æ—Ä—Ç –≤—á–µ—Ä–∞."
 - "–ù–æ —è —É–∂–µ —Å—ä–µ–ª %s —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞."
 - "–ù–æ —è —É–∂–µ —Å—ä–µ–ª %s —Ç–æ—Ä—Ç–æ–≤ –≤—á–µ—Ä–∞."
```

`example.php`:
```PHP
<?php
// For English.
$rawData = file_get_contents(__DIR__ . '/english.yaml');
$English = new \Maikuolan\Common\YAML($rawData);

// For Russian.
$rawData = file_get_contents(__DIR__ . '/russian.yaml');
$Russian = new \Maikuolan\Common\YAML($rawData);

// Instantiate L10N object.
$L10N = new \Maikuolan\Common\L10N($English->Data, $Russian->Data);

// Now, about those cakes...
foreach ([1, 2, 4, 7] as $Today) {
    foreach ([1, 2, 4, 7] as $Yesterday) {
        echo $L10N->getString('Hello') . ' ';
        echo sprintf($L10N->getPlural($Today, 'Today\'s cakes'), $Today) . ' ';
        echo sprintf($L10N->getPlural($Yesterday, 'Yesterday\'s cakes'), $Yesterday) . PHP_EOL;
    }
}
echo PHP_EOL;

// Or.. Swapping the languages around...
$L10N = new \Maikuolan\Common\L10N($Russian->Data, $English->Data);

// And...
foreach ([1, 2, 4, 7] as $Today) {
    foreach ([1, 2, 4, 7] as $Yesterday) {
        echo $L10N->getString('Hello') . ' ';
        echo sprintf($L10N->getPlural($Today, 'Today\'s cakes'), $Today) . ' ';
        echo sprintf($L10N->getPlural($Yesterday, 'Yesterday\'s cakes'), $Yesterday) . PHP_EOL;
    }
}
echo PHP_EOL;
```

The resulting output:

```

Hello! Today, there is 1 cake in the shop. But, I already ate 1 cake yesterday.
Hello! Today, there is 1 cake in the shop. But, I already ate 2 cakes yesterday.
Hello! Today, there is 1 cake in the shop. But, I already ate 4 cakes yesterday.
Hello! Today, there is 1 cake in the shop. But, I already ate 7 cakes yesterday.
Hello! Today, there are 2 cakes in the shop. But, I already ate 1 cake yesterday.
Hello! Today, there are 2 cakes in the shop. But, I already ate 2 cakes yesterday.
Hello! Today, there are 2 cakes in the shop. But, I already ate 4 cakes yesterday.
Hello! Today, there are 2 cakes in the shop. But, I already ate 7 cakes yesterday.
Hello! Today, there are 4 cakes in the shop. But, I already ate 1 cake yesterday.
Hello! Today, there are 4 cakes in the shop. But, I already ate 2 cakes yesterday.
Hello! Today, there are 4 cakes in the shop. But, I already ate 4 cakes yesterday.
Hello! Today, there are 4 cakes in the shop. But, I already ate 7 cakes yesterday.
Hello! Today, there are 7 cakes in the shop. But, I already ate 1 cake yesterday.
Hello! Today, there are 7 cakes in the shop. But, I already ate 2 cakes yesterday.
Hello! Today, there are 7 cakes in the shop. But, I already ate 4 cakes yesterday.
Hello! Today, there are 7 cakes in the shop. But, I already ate 7 cakes yesterday.

–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 1 —Ç–æ—Ä—Ç. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 1 —Ç–æ—Ä—Ç –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 1 —Ç–æ—Ä—Ç. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 2 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 1 —Ç–æ—Ä—Ç. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 4 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 1 —Ç–æ—Ä—Ç. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 7 —Ç–æ—Ä—Ç–æ–≤ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 2 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 1 —Ç–æ—Ä—Ç –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 2 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 2 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 2 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 4 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 2 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 7 —Ç–æ—Ä—Ç–æ–≤ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 4 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 1 —Ç–æ—Ä—Ç –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 4 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 2 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 4 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 4 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 4 —Ç–æ—Ä—Ç–∞. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 7 —Ç–æ—Ä—Ç–æ–≤ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 7 —Ç–æ—Ä—Ç–æ–≤. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 1 —Ç–æ—Ä—Ç –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 7 —Ç–æ—Ä—Ç–æ–≤. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 2 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 7 —Ç–æ—Ä—Ç–æ–≤. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 4 —Ç–æ—Ä—Ç–∞ –≤—á–µ—Ä–∞.
–ü—Ä–∏–≤–µ—Ç! –°–µ–≥–æ–¥–Ω—è –≤ –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å 7 —Ç–æ—Ä—Ç–æ–≤. –ù–æ —è —É–∂–µ —Å—ä–µ–ª 7 —Ç–æ—Ä—Ç–æ–≤ –≤—á–µ—Ä–∞.
```

Of course, how you choose to use these classes, and how you choose to store your L10N data, is ultimately up to you.

---


#### Object chaining.

If you want, it's possible to chain together multiple L10N objects via L10N's fallback mechanism.

As an example:

```PHP
<?php
$English = ['Hello' => 'Hello', 'World' => 'World', 'Something English' => 'Bangers and mash'];
$French = ['Hello' => 'Bonjour', 'World' => 'Monde', 'Something French' => 'Vin et croissants'];
$Russian = ['Hello' => '–ü—Ä–∏–≤–µ—Ç', 'World' => '–ú–∏—Ä', 'Something Russian' => '–í–æ–¥–∫–∞ –∏ –±–æ—Ä—â'];
$German = ['Hallo' => 'Hello', 'World' => 'Welt', 'Something German' => 'Brezeln und Bier'];

$Foo = new \Maikuolan\Common\L10N($German, $Russian);
$Bar = new \Maikuolan\Common\L10N($French, $Foo);
$Foobar = new \Maikuolan\Common\L10N($English, $Bar);

echo $Foobar->getString('Hello').PHP_EOL;
echo $Foobar->getString('World').PHP_EOL;
echo $Foobar->getString('Something English').PHP_EOL;
echo $Foobar->getString('Something French').PHP_EOL;
echo $Foobar->getString('Something Russian').PHP_EOL;
echo $Foobar->getString('Something German').PHP_EOL;
```

The resulting output:

```
Hello
World
Bangers and mash
Vin et croissants
–í–æ–¥–∫–∞ –∏ –±–æ—Ä—â
Brezeln und Bier
```

This means, that in theory, you could have an unlimited number of languages as fallbacks for your L10N data.

---


Last Updated: 19 June 2022 (2022.06.19).
